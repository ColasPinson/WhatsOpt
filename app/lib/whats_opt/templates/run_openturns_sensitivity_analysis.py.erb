# DO NOT EDIT unless you know what you are doing
# analysis_id: <%= @mda.id %>

import sys
import numpy as np
import openturns as ot
import json

<% @input_varcases.each do |vc| %>
names.append("<%= vc.float_varname %>")
X.append(np.array(<%= vc.values %>))
<% end %>
X = np.vstack(inputs)
X = inputs.T

Data = np.array(X)
result = {}

<% @output_varcases.each do |vc| %>
# <%= vc.float_varname %>
outname = '<%= vc.float_varname %>'
result[outname] = {}
Y = np.array(<%= vc.values %>).T
Data = np.hstack(Data, Y)
repet = 1

for j in range(repet):



    sensitivityAnalysis = ot.FunctionalChaosSobolIndices(pceResult)
    first_order = list(map(lambda i: sensitivityAnalysis.getSobolIndex(i), range(inputDim)))
    total_index = list(map(lambda i: sensitivityAnalysis.getSobolTotalIndex(i), range(inputDim)))

    result_tmp = {k:v for k, v in Si.items() if k is not 'names'}
    result[outname] = {k:v.tolist() for k, v in result_tmp.items() if isinstance(v, np.ndarray)}
    result[outname]['parameter_names'] = names
<% end %>

#loop of the output
for output_index in range(outputDim):
	Y = Data[:,inputDim+output_index]
#to choose randomly a validation set for the bootstrap  
	for j in range(repet):
        #to choose randomly a validation set for the bootstrap 
         Ind_valid = np.random.choice(Data.shape[0],size_validation,replace=False)
         Ind_valid.sort()
         X_validation = X[Ind_valid,:]
         Y_validation = Y[Ind_valid].reshape((len(Ind_valid),1))
        #to choose the training set associated 
         Ind_train = np.setdiff1d(np.linspace(0,Data.shape[0]-1,Data.shape[0]).astype('int'),Ind_valid)
         X_train = X[Ind_train,:]
         Y_train = Y[Ind_train].reshape((Data.shape[0]-len(Ind_valid),1))	
         # Polynomial Chaos to build on the training set
         X_train_NS = ot.Sample(X_train)
         Y_train_NS = ot.Sample(Y_train)
         # Distribution choice of the inputs to Create the input distribution
         if normed_input == True:
             distribution = ot.ComposedDistribution([ot.Uniform(0.0,1.0)]*inputDim)
         else:
             distributions = []
             for i in range(inputDim):
                 distributions.append(ot.Uniform(bounds[i][0],bounds[i][1]))
             distribution = ot.ComposedDistribution(distributions)	
        # Polynomial basis
        #Step 1 - Construction of the multivariate orthonormal basis:
         polyColl = [0.0]*inputDim
        #Build orthonormal or orthogonal univariate polynomial families (associated to associated input distribution)
         for i in range(distribution.getDimension()):
             polyColl[i] = ot.StandardDistributionPolynomialFactory(distribution.getMarginal(i))
         #Define the numerotation of the multivariate orthonormal basis
         enumerateFunction = ot.LinearEnumerateFunction(inputDim)
        #Build the multivariate orthonormal basis 
         productBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction) 
        
        #Step 2 - Truncation strategy of the multivariate orthonormal basis: a strategy must be chosen 
        #for the selection of the different terms of the multivariate basis.
        # Truncature strategy of the multivariate orthonormal basis
        # We choose all the polynomials of degree <= degree
         indexMax = enumerateFunction.getStrataCumulatedCardinal(degree)
         adaptiveStrategy = ot.FixedStrategy(productBasis, indexMax)
         print(indexMax)
        
         basisSequenceFactory = ot.LARS()
         fittingAlgorithm = ot.CorrectedLeaveOneOut()
         approximationAlgorithm = ot.LeastSquaresMetaModelSelectionFactory(basisSequenceFactory,fittingAlgorithm)
         
         #Step 3 - Define the evaluation strategy of the coefficients:
         #with the LeastSquaresStrategy, the coefficients minimize the quadratic error between the model 
         # and the polynomial approximation. 
         projection_strategy = ot.LeastSquaresStrategy(X_train_NS, Y_train_NS, approximationAlgorithm)
         compute_strat_ls = ot.LeastSquaresStrategy(X_train_NS, Y_train_NS)
         
         #Create the Functional Chaos Algorithm:
         algo = ot.FunctionalChaosAlgorithm(X_train_NS, Y_train_NS, distribution, 
                                            adaptiveStrategy,projection_strategy)
         
         algo.run()
           
         #Get the result:   
         result = algo.getResult()
         responseSurface = result.getMetaModel()
         
         #Validation set
         X_validation_NS = ot.Sample(X_validation)
         Y_pred_NS = responseSurface(X_validation_NS)
         Y_pred = np.array(Y_pred_NS)
         
         #Training set
         Y_pred_NS_2 = responseSurface(X_train_NS)
         Y_pred_2 = np.array(Y_pred_NS_2)
         
         R2 = np.sum((Y_pred_2[:,0]-Y_train.mean())**2)/np.sum((Y_train[:,0]-Y_train.mean())**2)
         
       
         rel_L_2 = np.sqrt(((Y_pred[:,0]-Y_validation[:,0])**2).mean())/Y_validation[:,0].mean()
         Rel_error = abs((Y_pred[:,0]-Y_validation[:,0]))/abs((Y_validation[:,0]))
         Rel_error = Rel_error.mean()
         sensitivityAnalysis = ot.FunctionalChaosSobolIndices(result)
         first_order = list(map(lambda i: sensitivityAnalysis.getSobolIndex(i), range(inputDim)))
         total_index = list(map(lambda i: sensitivityAnalysis.getSobolTotalIndex(i), range(inputDim)))
         
       
         L_First_Order.append(first_order)
         L_Total_Index.append(total_index)
         L_Mean_Square_Error.append(rel_L_2)
         L_R2.append(R2)
         L_Rel_Error.append(Rel_error)


<% @output_varcases.each do |vc| %>
# <%= vc.float_varname %>
outname = '<%= vc.float_varname %>'
result[outname] = {}
output = np.array(<%= vc.values %>)
<% if @sobol %>
Si = analyser.analyze(salib_pb, output, calc_second_order=False, print_to_console=False)
<% else %>
Si = analyser.analyze(salib_pb, inputs, output, print_to_console=False)
<% end%>
result_tmp = {k:v for k, v in Si.items() if k is not 'names'}
result[outname] = {k:v.tolist() for k, v in result_tmp.items() if isinstance(v, np.ndarray)}
result[outname]['parameter_names'] = names
<% end %>

sa_result = {'saMethod': "<%= @sobol ? "sobol" : "morris" %>", 'saResult': result}

print(json.dumps(sa_result))
